#include "tui/tui.h"
#include "tui/bip39_wordlist.h"
#include "screens.h"
#include <ncurses.h>
#include <atomic>
#include <thread>
#include <chrono>
#include <ctime>
#include <sstream>
#include <iomanip>
#include <cstring>
#include <algorithm>
#include <random>
#include <array>
#include <filesystem>
#include <cstdio>

namespace synapse {
namespace tui {

static const char* LOGO_SYNAPSENET[] = {
    " _____                                 _   ",
    "|   __|_ _ ___ ___ ___ ___ ___ ___ ___| |_ ",
    "|__   | | |   | .'| . |_ -| -_|   | -_|  _|",
    "|_____|_  |_|_|__,|  _|___|___|_|_|___|_|  ",
    "      |___|       |_|                      "
};
static const int LOGO_SYNAPSENET_COUNT = 5;

static const char* LOGO_KEPLER[] = {
    " _____         _         ",
    "|  |  |___ ___| |___ ___ ",
    "|    -| -_| . | | -_|  _|",
    "|__|__|___|  _|_|___|_|  ",
    "          |_|            "
};
static const int LOGO_KEPLER_COUNT = 5;

struct ChatMessage {
    std::string role;
    std::string content;
};

struct LocalAppState {
    WalletInfo wallet;
    NetworkInfo network;
    AIModelInfo model;
    std::vector<NodeInfo> peers;
    std::vector<ContributionInfo> recentContributions;
    int qualityScore = 0;
    int networkRank = 0;
    int knowledgeShared = 0;
    int validations = 0;
    std::string nodeId;
    bool isFirstRun = true;
    std::vector<std::string> generatedSeedWords;
    double miningProgress = 0;
    std::vector<ChatMessage> chatHistory;
    bool aiGenerating = false;
    std::string modelPath;
    uint16_t listeningPort = 0;
    bool networkOnline = false;
    std::string sendToAddress;
    double sendAmount = 0.0;
    int walletScreen = 0;
    std::vector<std::string> availableModels;
    int selectedModelIndex = 0;
    bool modelSelectionActive = false;
};

struct TUI::Impl {
    Screen screen = Screen::BOOT;
    std::atomic<bool> running{false};
    StatusInfo status{};
    LocalAppState state{};
    std::function<void(int)> inputHandler;
    std::function<void(const std::string&)> commandHandler;
    int initStep = 0;
    int frameCounter = 0;
    int menuSelection = 0;
    int scrollOffset = 0;
    std::string inputBuffer;
    
    void drawBoot();
    void drawInit();
    void drawNetworkDiscovery();
    void drawSyncing();
    void drawWelcome();
    void drawWalletCreate();
    void drawWalletCreated();
    void drawConnected();
    void drawDashboard();
    void drawWallet();
    void drawNetwork();
    void drawKnowledge();
    void drawModel();
    void drawAIChat();
    void drawSecurity();
    void drawSettings();
    void drawMining();
    void drawModelLoader();
    void drawSendNGT();
    void drawReceiveNGT();
    void drawStatusBar();
    void drawBox(int y, int x, int h, int w, const char* title);
    void drawDoubleBox(int y, int x, int h, int w);
    void drawProgressBar(int y, int x, int w, double progress, int color);
    void centerText(int y, const char* text);
    void initDefaultState();
};

void TUI::Impl::initDefaultState() {
    state.wallet.address = "";
    state.wallet.balance = 0.0;
    state.wallet.pending = 0.0;
    state.wallet.totalEarned = 0.0;
    
    state.network.totalNodes = 0;
    state.network.knowledgeEntries = 0;
    state.network.networkSize = 0.0;
    state.network.yourStorage = 0.0;
    state.network.syncProgress = 0.0;
    state.network.synced = false;
    
    state.model.name = "";
    state.model.status = "NOT LOADED";
    state.model.progress = 0.0;
    state.model.mode = "PRIVATE";
    state.model.slotsUsed = 0;
    state.model.slotsMax = 0;
    state.model.uptime = 0.0;
    state.model.earningsToday = 0.0;
    state.model.earningsWeek = 0.0;
    state.model.earningsTotal = 0.0;
    
    state.nodeId = "";
    state.qualityScore = 0;
    state.networkRank = 0;
    state.knowledgeShared = 0;
    state.validations = 0;
    state.miningProgress = 0.0;
    state.isFirstRun = true;
    state.chatHistory.clear();
    state.aiGenerating = false;
    state.modelPath = "";
    state.listeningPort = 0;
    state.networkOnline = false;
    
    state.peers.clear();
    state.recentContributions.clear();
}

void TUI::Impl::drawBox(int y, int x, int h, int w, const char* title) {
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    if (title && strlen(title) > 0) {
        mvprintw(y, x + 2, "[%s]", title);
    }
}

void TUI::Impl::drawDoubleBox(int y, int x, int h, int w) {
    for (int i = x; i < x + w; i++) {
        mvprintw(y, i, "=");
        mvprintw(y + h - 1, i, "=");
    }
    for (int i = y; i < y + h; i++) {
        mvprintw(i, x, "|");
        mvprintw(i, x + w - 1, "|");
    }
    mvprintw(y, x, "+");
    mvprintw(y, x + w - 1, "+");
    mvprintw(y + h - 1, x, "+");
    mvprintw(y + h - 1, x + w - 1, "+");
}

void TUI::Impl::drawProgressBar(int y, int x, int w, double progress, int color) {
    int filled = static_cast<int>(progress * (w - 2));
    mvaddch(y, x, '[');
    attron(COLOR_PAIR(color));
    for (int i = 0; i < w - 2; i++) {
        if (i < filled) {
            mvprintw(y, x + 1 + i, "#");
        } else {
            mvaddch(y, x + 1 + i, ' ');
        }
    }
    attroff(COLOR_PAIR(color));
    mvaddch(y, x + w - 1, ']');
}

void TUI::Impl::centerText(int y, const char* text) {
    int cols = COLS;
    int len = strlen(text);
    int xpos = (cols - len) / 2;
    if (xpos < 0) xpos = 0;
    mvprintw(y, xpos, "%s", text);
}

void TUI::Impl::drawBoot() {
    clear();
    int row = 2;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    for (int i = 0; i < LOGO_SYNAPSENET_COUNT; i++) {
        centerText(row++, LOGO_SYNAPSENET[i]);
    }
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row += 2;
    attron(COLOR_PAIR(6));
    centerText(row++, "A Decentralized Intelligence Network");
    centerText(row++, "Version 0.1.0-alpha");
    centerText(row++, "by Kepler");
    attroff(COLOR_PAIR(6));
    
    row += 2;
    attron(COLOR_PAIR(2));
    centerText(row++, "\"Satoshi gave us money without banks.");
    centerText(row++, " I will give you brains without corporations.\"");
    row++;
    centerText(row++, "                                        - Kepler");
    attroff(COLOR_PAIR(2));
    
    row += 3;
    attron(A_BLINK);
    centerText(row, "Press [SPACE] to continue");
    attroff(A_BLINK);
    
    ::refresh();
}


void TUI::Impl::drawInit() {
    clear();
    int row = 3;
    
    attron(COLOR_PAIR(1) | A_BOLD);
    centerText(row++, "Initializing SynapseNet Protocol...");
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    row += 2;
    double progress = (initStep + 1) / 5.0;
    int barWidth = 42;
    int startX = (COLS - barWidth) / 2;
    
    mvaddch(row, startX, '[');
    attron(COLOR_PAIR(1));
    for (int i = 0; i < 40; i++) {
        if (i < static_cast<int>(progress * 40)) {
            mvprintw(row, startX + 1 + i, "#");
        } else {
            mvaddch(row, startX + 1 + i, ' ');
        }
    }
    attroff(COLOR_PAIR(1));
    mvaddch(row, startX + 41, ']');
    mvprintw(row, startX + 44, "%d%%", static_cast<int>(progress * 100));
    
    row += 3;
    
    const char* steps[] = {
        "Loading configuration...",
        "Initializing cryptography...",
        "Generating wallet keys...",
        "Initializing network...",
        "Starting node..."
    };
    
    const char* details[] = {
        "Reading synapsenet.conf",
        "CRYSTALS-Dilithium + Kyber",
        "Quantum-resistant keypair",
        "Binding to port %d",
        "Ready for connections"
    };
    
    for (int i = 0; i < 5; i++) {
        if (i < initStep) {
            attron(COLOR_PAIR(1));
            mvprintw(row, startX, "[OK]");
            attroff(COLOR_PAIR(1));
            mvprintw(row, startX + 5, " %s", steps[i]);
            if (i == 3 && state.listeningPort > 0) {
                mvprintw(row, startX + 30, "(port %d)", state.listeningPort);
            }
        } else if (i == initStep) {
            attron(COLOR_PAIR(2));
            mvprintw(row, startX, "[..]");
            attroff(COLOR_PAIR(2));
            mvprintw(row, startX + 5, " %s", steps[i]);
            
            static int dots = 0;
            dots = (dots + 1) % 4;
            for (int d = 0; d < dots; d++) {
                mvprintw(row, startX + 5 + strlen(steps[i]) + d, ".");
            }
        } else {
            attron(COLOR_PAIR(7));
            mvprintw(row, startX, "[  ]");
            attroff(COLOR_PAIR(7));
            mvprintw(row, startX + 5, " %s", steps[i]);
        }
        row++;
    }
    
    row += 2;
    if (initStep < 5) {
        attron(COLOR_PAIR(7));
        mvprintw(row, startX, "%s", details[initStep]);
        attroff(COLOR_PAIR(7));
    }
    
    ::refresh();
    
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    
    if (initStep < 4) {
        initStep++;
    } else {
        screen = Screen::NETWORK_DISCOVERY;
    }
}

void TUI::Impl::drawNetworkDiscovery() {
    clear();
    int row = 2;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "Network Status");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row += 1;
    drawBox(row, boxX, 16, boxW, "");
    
    int innerRow = row + 2;
    
    size_t realPeers = state.peers.size();
    
    if (state.listeningPort > 0) {
        attron(COLOR_PAIR(1) | A_BOLD);
        mvprintw(innerRow++, boxX + 3, "NODE STATUS: ONLINE");
        attroff(COLOR_PAIR(1) | A_BOLD);
        innerRow++;
        attron(COLOR_PAIR(1));
        mvprintw(innerRow++, boxX + 3, "Listening:    port %d", state.listeningPort);
        mvprintw(innerRow++, boxX + 3, "Protocol:     SynapseNet v0.1");
        mvprintw(innerRow++, boxX + 3, "Encryption:   CRYSTALS-Kyber (quantum-safe)");
        attroff(COLOR_PAIR(1));
    } else {
        attron(COLOR_PAIR(2) | A_BOLD);
        mvprintw(innerRow++, boxX + 3, "NODE STATUS: OFFLINE");
        attroff(COLOR_PAIR(2) | A_BOLD);
        innerRow++;
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "Could not bind to any port");
        mvprintw(innerRow++, boxX + 3, "Running in local-only mode");
        attroff(COLOR_PAIR(2));
    }
    
    innerRow++;
    mvprintw(innerRow++, boxX + 3, "----------------------------------------");
    innerRow++;
    
    if (realPeers == 0) {
        mvprintw(innerRow++, boxX + 3, "Connected Peers: 0");
        innerRow++;
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "GENESIS MODE - First node on network");
        mvprintw(innerRow++, boxX + 3, "Waiting for other nodes to connect...");
        attroff(COLOR_PAIR(2));
    } else {
        mvprintw(innerRow++, boxX + 3, "Connected Peers: %zu", realPeers);
        innerRow++;
        for (size_t i = 0; i < state.peers.size() && i < 5; i++) {
            attron(COLOR_PAIR(1));
            mvprintw(innerRow++, boxX + 5, "* %s", state.peers[i].id.c_str());
            attroff(COLOR_PAIR(1));
        }
    }
    
    row += 18;
    
    if (state.listeningPort > 0) {
        attron(COLOR_PAIR(1));
        centerText(row, "Network: READY");
        attroff(COLOR_PAIR(1));
    } else {
        attron(COLOR_PAIR(2));
        centerText(row, "Network: OFFLINE");
        attroff(COLOR_PAIR(2));
    }
    
    ::refresh();
    
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    static int waitCount = 0;
    waitCount++;
    if (waitCount > 15) {
        waitCount = 0;
        screen = Screen::SYNCING;
        state.network.syncProgress = 0.0;
    }
}

void TUI::Impl::drawSyncing() {
    clear();
    int row = 2;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "Knowledge Network");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row += 1;
    drawBox(row, boxX, 14, boxW, "");
    
    int innerRow = row + 2;
    
    size_t realPeers = state.peers.size();
    
    if (realPeers == 0) {
        attron(COLOR_PAIR(1) | A_BOLD);
        mvprintw(innerRow++, boxX + 3, "GENESIS NODE");
        attroff(COLOR_PAIR(1) | A_BOLD);
        innerRow++;
        
        mvprintw(innerRow++, boxX + 3, "You are starting a new network.");
        mvprintw(innerRow++, boxX + 3, "");
        mvprintw(innerRow++, boxX + 3, "Knowledge Chain:  Empty (genesis block)");
        mvprintw(innerRow++, boxX + 3, "Network Size:     0 bytes");
        mvprintw(innerRow++, boxX + 3, "Your Storage:     0 bytes");
        innerRow++;
        
        attron(COLOR_PAIR(1));
        mvprintw(innerRow++, boxX + 3, "Status: Ready to accept connections");
        attroff(COLOR_PAIR(1));
        
        state.network.syncProgress = 1.0;
        state.network.synced = true;
    } else {
        attron(A_BOLD);
        mvprintw(innerRow++, boxX + 3, "SYNCHRONIZING");
        attroff(A_BOLD);
        innerRow++;
        
        mvprintw(innerRow++, boxX + 3, "Network Size:     %.1f GB", state.network.networkSize);
        mvprintw(innerRow++, boxX + 3, "Downloaded:       %.1f GB", state.network.networkSize * state.network.syncProgress);
        mvprintw(innerRow++, boxX + 3, "Entries:          %lu", state.network.knowledgeEntries);
        innerRow++;
        
        mvprintw(innerRow, boxX + 3, "Progress: ");
        int barX = boxX + 13;
        mvaddch(innerRow, barX, '[');
        attron(COLOR_PAIR(1));
        int filled = static_cast<int>(state.network.syncProgress * 40);
        for (int i = 0; i < 40; i++) {
            mvprintw(innerRow, barX + 1 + i, i < filled ? "#" : " ");
        }
        attroff(COLOR_PAIR(1));
        mvaddch(innerRow, barX + 41, ']');
        mvprintw(innerRow++, barX + 43, "%d%%", static_cast<int>(state.network.syncProgress * 100));
    }
    
    row += 16;
    
    if (state.network.synced) {
        attron(COLOR_PAIR(1));
        centerText(row, "Sync: COMPLETE");
        attroff(COLOR_PAIR(1));
    }
    
    ::refresh();
    
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    static int syncWait = 0;
    syncWait++;
    
    if (realPeers > 0 && state.network.syncProgress < 1.0) {
        state.network.syncProgress += 0.05;
    }
    
    if (syncWait > 10) {
        syncWait = 0;
        state.network.syncProgress = 1.0;
        state.network.synced = true;
        if (state.isFirstRun) {
            screen = Screen::WELCOME;
        } else {
            screen = Screen::DASHBOARD;
        }
    }
}

void TUI::Impl::drawWelcome() {
    clear();
    int boxW = 76;
    int boxH = 20;
    int boxX = (COLS - boxW) / 2;
    int boxY = (LINES - boxH) / 2;
    
    attron(COLOR_PAIR(4));
    for (int i = boxX; i < boxX + boxW; i++) {
        mvprintw(boxY, i, "=");
        mvprintw(boxY + boxH - 1, i, "=");
    }
    for (int i = boxY; i < boxY + boxH; i++) {
        mvprintw(i, boxX, "|");
        mvprintw(i, boxX + boxW - 1, "|");
    }
    mvprintw(boxY, boxX, "+");
    mvprintw(boxY, boxX + boxW - 1, "+");
    mvprintw(boxY + boxH - 1, boxX, "+");
    mvprintw(boxY + boxH - 1, boxX + boxW - 1, "+");
    attroff(COLOR_PAIR(4));
    
    int row = boxY + 2;
    attron(COLOR_PAIR(1) | A_BOLD);
    centerText(row++, "WELCOME TO SYNAPSENET");
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    row += 1;
    centerText(row++, "This appears to be your first time running SynapseNet.");
    row += 1;
    
    int menuX = boxX + 5;
    drawBox(row, menuX, 10, boxW - 10, "");
    
    int menuRow = row + 2;
    attron(COLOR_PAIR(4) | A_BOLD);
    mvprintw(menuRow++, menuX + 3, "[1] Create New Wallet");
    attroff(COLOR_PAIR(4) | A_BOLD);
    mvprintw(menuRow++, menuX + 3, "    Generate a new quantum-safe wallet and seed phrase");
    menuRow++;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    mvprintw(menuRow++, menuX + 3, "[2] Import Existing Wallet");
    attroff(COLOR_PAIR(4) | A_BOLD);
    mvprintw(menuRow++, menuX + 3, "    Restore from seed phrase or private key");
    menuRow++;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    mvprintw(menuRow++, menuX + 3, "[3] View Documentation");
    attroff(COLOR_PAIR(4) | A_BOLD);
    mvprintw(menuRow++, menuX + 3, "    Learn about SynapseNet before starting");
    
    row = boxY + boxH - 3;
    mvprintw(row, menuX + 3, "Select option [1-3]: _");
    
    ::refresh();
}

void TUI::Impl::drawWalletCreate() {
    clear();
    int row = 2;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    if (state.generatedSeedWords.empty()) {
        std::random_device rd;
        
        auto now = std::chrono::high_resolution_clock::now();
        auto nanos = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
        
        std::array<uint32_t, 16> seed_data;
        for (size_t i = 0; i < seed_data.size(); i++) {
            seed_data[i] = rd() ^ static_cast<uint32_t>(nanos >> (i * 2));
        }
        seed_data[0] ^= static_cast<uint32_t>(std::hash<std::thread::id>{}(std::this_thread::get_id()));
        seed_data[1] ^= static_cast<uint32_t>(reinterpret_cast<uintptr_t>(&state));
        
        std::seed_seq seq(seed_data.begin(), seed_data.end());
        std::mt19937_64 gen(seq);
        std::uniform_int_distribution<> dis(0, BIP39_WORDLIST_SIZE - 1);
        
        state.generatedSeedWords.clear();
        for (int i = 0; i < 24; i++) {
            state.generatedSeedWords.push_back(BIP39_WORDLIST[dis(gen)]);
        }
    }
    
    attron(COLOR_PAIR(1) | A_BOLD);
    centerText(row++, "CREATING NEW WALLET");
    mvprintw(row++, boxX, "===================");
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    row += 1;
    centerText(row++, "Generating quantum-resistant keys...");
    row += 1;
    
    drawBox(row, boxX, 18, boxW, "");
    
    int innerRow = row + 2;
    attron(COLOR_PAIR(3) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "!!! IMPORTANT: SAVE YOUR SEED PHRASE !!!");
    attroff(COLOR_PAIR(3) | A_BOLD);
    innerRow++;
    
    mvprintw(innerRow++, boxX + 3, "Your 24-word seed phrase is the ONLY way to recover your wallet.");
    mvprintw(innerRow++, boxX + 3, "Write it down on paper. Do NOT store digitally. Do NOT share.");
    innerRow++;
    
    int seedBoxX = boxX + 5;
    drawBox(innerRow, seedBoxX, 8, boxW - 10, "");
    
    int seedRow = innerRow + 2;
    attron(COLOR_PAIR(4));
    for (int i = 0; i < 6; i++) {
        mvprintw(seedRow, seedBoxX + 3, "%2d. %-12s", i + 1, state.generatedSeedWords[i].c_str());
        mvprintw(seedRow, seedBoxX + 19, "%2d. %-12s", i + 7, state.generatedSeedWords[i + 6].c_str());
        mvprintw(seedRow, seedBoxX + 35, "%2d. %-12s", i + 13, state.generatedSeedWords[i + 12].c_str());
        mvprintw(seedRow, seedBoxX + 51, "%2d. %-12s", i + 19, state.generatedSeedWords[i + 18].c_str());
        seedRow++;
    }
    attroff(COLOR_PAIR(4));
    
    innerRow += 10;
    mvprintw(innerRow, boxX + 3, "Have you written down your seed phrase? [y/n]: _");
    
    ::refresh();
}


void TUI::Impl::drawWalletCreated() {
    clear();
    int row = 2;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    attron(COLOR_PAIR(1) | A_BOLD);
    centerText(row++, "WALLET CREATED SUCCESSFULLY");
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    row += 1;
    drawBox(row, boxX, 18, boxW, "");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Your Wallet Address:");
    mvprintw(innerRow++, boxX + 3, "============================================");
    innerRow++;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "%s", state.wallet.address.c_str());
    attroff(COLOR_PAIR(4) | A_BOLD);
    innerRow++;
    
    mvprintw(innerRow++, boxX + 3, "Balance:           0.00 NGT");
    mvprintw(innerRow++, boxX + 3, "Status:            Active");
    mvprintw(innerRow++, boxX + 3, "Protection:        Quantum-Resistant (CRYSTALS-Dilithium)");
    innerRow++;
    
    for (int i = 0; i < boxW - 6; i++) {
        mvaddch(innerRow, boxX + 3 + i, '-');
    }
    innerRow += 2;
    
    mvprintw(innerRow++, boxX + 3, "Start earning NGT by:");
    attron(COLOR_PAIR(1));
    mvprintw(innerRow++, boxX + 5, "* Contributing knowledge to the network");
    mvprintw(innerRow++, boxX + 5, "* Validating others' contributions");
    mvprintw(innerRow++, boxX + 5, "* Keeping your node online");
    attroff(COLOR_PAIR(1));
    
    row += 20;
    attron(A_BLINK);
    centerText(row, "Press [ENTER] to continue to dashboard...");
    attroff(A_BLINK);
    
    ::refresh();
}

void TUI::Impl::drawConnected() {
    clear();
    int row = 2;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    attron(COLOR_PAIR(1) | A_BOLD);
    centerText(row++, "SYNAPSENET CONNECTED");
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    row += 1;
    drawBox(row, boxX, 18, boxW, "");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Node ID:           %s", state.nodeId.c_str());
    
    attron(COLOR_PAIR(1));
    mvprintw(innerRow++, boxX + 3, "Status:            * ONLINE");
    attroff(COLOR_PAIR(1));
    
    std::string shortAddr = state.wallet.address.empty() ? "not set" : 
        state.wallet.address.substr(0, 10) + "..." + state.wallet.address.substr(state.wallet.address.length() - 4);
    mvprintw(innerRow++, boxX + 3, "Wallet:            %s", shortAddr.c_str());
    mvprintw(innerRow++, boxX + 3, "Balance:           %.2f NGT", state.wallet.balance);
    innerRow++;
    
    for (int i = 0; i < boxW - 6; i++) {
        mvaddch(innerRow, boxX + 3 + i, '-');
    }
    innerRow += 2;
    
    mvprintw(innerRow++, boxX + 3, "Network:           %lu nodes online", state.network.totalNodes);
    mvprintw(innerRow++, boxX + 3, "Knowledge Chain:   %.1f GB (%s)", 
             state.network.networkSize, state.network.synced ? "synced" : "syncing");
    mvprintw(innerRow++, boxX + 3, "Your Contribution: %d entries", state.knowledgeShared);
    mvprintw(innerRow++, boxX + 3, "Quality Score:     %.1f%%", static_cast<double>(state.qualityScore));
    innerRow++;
    
    for (int i = 0; i < boxW - 6; i++) {
        mvaddch(innerRow, boxX + 3 + i, '-');
    }
    innerRow += 2;
    
    mvprintw(innerRow++, boxX + 3, "Last Session:      First time");
    attron(COLOR_PAIR(1));
    mvprintw(innerRow++, boxX + 3, "Welcome to SynapseNet!");
    attroff(COLOR_PAIR(1));
    
    row += 20;
    centerText(row, "Loading dashboard...");
    row += 2;
    centerText(row, "Press [ENTER] to continue");
    
    ::refresh();
}

void TUI::Impl::drawDashboard() {
    clear();
    int row = 0;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "================================================================================");
    centerText(row++, "SYNAPSENET v0.1");
    centerText(row++, "Decentralized AI Knowledge Network");
    centerText(row++, "================================================================================");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    attron(COLOR_PAIR(6));
    for (int i = 0; i < LOGO_KEPLER_COUNT; i++) {
        centerText(row++, LOGO_KEPLER[i]);
    }
    attroff(COLOR_PAIR(6));
    
    row++;
    attron(COLOR_PAIR(4));
    for (int i = 0; i < LOGO_SYNAPSENET_COUNT; i++) {
        centerText(row++, LOGO_SYNAPSENET[i]);
    }
    attroff(COLOR_PAIR(4));
    
    row += 2;
    centerText(row++, "--------------------------------------------------------------------------------");
    
    size_t realPeers = state.peers.size();
    if (state.listeningPort > 0) {
        attron(COLOR_PAIR(1));
        char statusLine[100];
        snprintf(statusLine, sizeof(statusLine), "ONLINE - Listening on port %d (Genesis Mode)", state.listeningPort);
        centerText(row++, statusLine);
        attroff(COLOR_PAIR(1));
    } else if (realPeers == 0) {
        attron(COLOR_PAIR(2));
        centerText(row++, "OFFLINE - No network port available");
        attroff(COLOR_PAIR(2));
    } else {
        attron(COLOR_PAIR(1));
        centerText(row++, "ONLINE - Connected to network");
        attroff(COLOR_PAIR(1));
    }
    centerText(row++, "--------------------------------------------------------------------------------");
    
    row++;
    int boxW = 31;
    int leftX = (COLS - 70) / 2;
    int rightX = leftX + boxW + 4;
    
    drawBox(row, leftX, 7, boxW, "CONNECTION");
    drawBox(row, rightX, 7, boxW, "WALLET");
    
    int innerRow = row + 1;
    if (state.listeningPort > 0) {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow, leftX + 2, "Status:    * ONLINE");
        attroff(COLOR_PAIR(1));
    } else {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow, leftX + 2, "Status:    * OFFLINE");
        attroff(COLOR_PAIR(2));
    }
    
    std::string shortAddr = state.wallet.address.empty() ? "not created" :
        state.wallet.address.substr(0, 8) + "..." + state.wallet.address.substr(state.wallet.address.length() - 4);
    mvprintw(innerRow++, rightX + 2, "Address: %s", shortAddr.c_str());
    
    mvprintw(innerRow, leftX + 2, "Peers:     %zu", realPeers);
    mvprintw(innerRow++, rightX + 2, "Balance: %.2f NGT", state.wallet.balance);
    
    mvprintw(innerRow, leftX + 2, "Port:      %d", state.listeningPort);
    mvprintw(innerRow++, rightX + 2, "Pending: +%.1f NGT", state.wallet.pending);
    
    mvprintw(innerRow, leftX + 2, "Network:   %s", state.listeningPort > 0 ? "Ready" : "Offline");
    mvprintw(innerRow++, rightX + 2, "Earned: %.2f NGT", state.wallet.totalEarned);
    
    if (realPeers == 0 && state.listeningPort > 0) {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow, leftX + 2, "[GENESIS NODE]");
        mvprintw(innerRow, rightX + 2, "[ONLINE]");
        attroff(COLOR_PAIR(1));
    } else if (state.listeningPort == 0) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow, leftX + 2, "[OFFLINE]");
        mvprintw(innerRow, rightX + 2, "[OFFLINE]");
        attroff(COLOR_PAIR(2));
    } else {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow, leftX + 2, "[CONNECTED]");
        mvprintw(innerRow, rightX + 2, "[ONLINE]");
        attroff(COLOR_PAIR(1));
    }
    
    row += 8;
    drawBox(row, leftX, 7, boxW, "LOCAL AI");
    drawBox(row, rightX, 7, boxW, "STATS");
    
    innerRow = row + 1;
    mvprintw(innerRow, leftX + 2, "Model:     %s", state.model.name.empty() ? "not loaded" : state.model.name.c_str());
    mvprintw(innerRow++, rightX + 2, "Knowledge: %d entries", state.knowledgeShared);
    
    if (!state.model.name.empty() && state.model.status == "ACTIVE") {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow, leftX + 2, "Status:    * READY");
        attroff(COLOR_PAIR(1));
    } else if (!state.model.name.empty()) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow, leftX + 2, "Status:    * LOADING");
        attroff(COLOR_PAIR(2));
    } else {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow, leftX + 2, "Status:    * NO MODEL");
        attroff(COLOR_PAIR(2));
    }
    mvprintw(innerRow++, rightX + 2, "Validations: %d", state.validations);
    
    mvprintw(innerRow, leftX + 2, "Mode:      %s", state.model.mode.c_str());
    mvprintw(innerRow++, rightX + 2, "Quality: %.1f%%", static_cast<double>(state.qualityScore));
    
    mvprintw(innerRow, leftX + 2, "Access:    PRIVATE");
    mvprintw(innerRow++, rightX + 2, "Rank: #%d", state.networkRank > 0 ? state.networkRank : 0);
    
    row += 9;
    centerText(row++, "--------------------------------------------------------------------------------");
    centerText(row++, "MENU");
    centerText(row++, "--------------------------------------------------------------------------------");
    
    row++;
    int menuX = leftX;
    mvprintw(row, menuX, "[1] AI Chat");
    mvprintw(row++, menuX + 30, "[5] Network");
    mvprintw(row, menuX, "[2] Load Model");
    mvprintw(row++, menuX + 30, "[6] Knowledge");
    mvprintw(row, menuX, "[3] Wallet");
    mvprintw(row++, menuX + 30, "[7] Settings");
    mvprintw(row, menuX, "[4] Mining");
    mvprintw(row++, menuX + 30, "[9] Change Model");
    
    row++;
    mvprintw(row++, menuX, "[Q] Quit");
    
    row++;
    centerText(row++, "--------------------------------------------------------------------------------");
    
    ::refresh();
}


void TUI::Impl::drawStatusBar() {
    int row = LINES - 1;
    attron(A_REVERSE);
    mvhline(row, 0, ' ', COLS);
    mvprintw(row, 2, " SynapseNet v0.1 | Peers: %lu | Balance: %.2f NGT | %s ",
             state.peers.size(), state.wallet.balance,
             state.network.synced ? "SYNCED" : "GENESIS");
    attroff(A_REVERSE);
}

void TUI::Impl::drawWallet() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "WALLET");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 70;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 12, boxW, "Balance");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Address:      %s", 
             state.wallet.address.empty() ? "not created" : state.wallet.address.c_str());
    innerRow++;
    
    attron(COLOR_PAIR(1) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "Balance:      %.2f NGT", state.wallet.balance);
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    attron(COLOR_PAIR(2));
    mvprintw(innerRow++, boxX + 3, "Pending:      +%.2f NGT", state.wallet.pending);
    attroff(COLOR_PAIR(2));
    
    mvprintw(innerRow++, boxX + 3, "Total Earned: %.2f NGT", state.wallet.totalEarned);
    innerRow++;
    mvprintw(innerRow++, boxX + 3, "Protection:   Quantum-Resistant (CRYSTALS-Dilithium)");
    
    row += 14;
    drawBox(row, boxX, 8, boxW, "Actions");
    
    innerRow = row + 2;
    mvprintw(innerRow++, boxX + 5, "[1] Send NGT");
    mvprintw(innerRow++, boxX + 5, "[2] Receive (Show Address)");
    mvprintw(innerRow++, boxX + 5, "[3] Transaction History");
    mvprintw(innerRow++, boxX + 5, "[4] Export Keys");
    mvprintw(innerRow++, boxX + 5, "[B] Back to Dashboard");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawNetwork() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "NETWORK STATUS");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 70;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 8, boxW, "Connection");
    
    int innerRow = row + 2;
    if (state.network.totalNodes > 0) {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow++, boxX + 3, "Status:       * ONLINE");
        attroff(COLOR_PAIR(1));
    } else {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "Status:       * GENESIS (waiting for peers)");
        attroff(COLOR_PAIR(2));
    }
    mvprintw(innerRow++, boxX + 3, "Total Nodes:  %lu", state.network.totalNodes);
    mvprintw(innerRow++, boxX + 3, "Connected:    %zu peers", state.peers.size());
    mvprintw(innerRow++, boxX + 3, "Latency:      --ms");
    
    row += 10;
    drawBox(row, boxX, 10, boxW, "Connected Peers");
    
    innerRow = row + 2;
    if (state.peers.empty()) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "No peers connected yet.");
        mvprintw(innerRow++, boxX + 3, "Waiting for network bootstrap...");
        attroff(COLOR_PAIR(2));
    } else {
        for (const auto& peer : state.peers) {
            attron(COLOR_PAIR(1));
            mvprintw(innerRow, boxX + 3, "* %s", peer.id.c_str());
            attroff(COLOR_PAIR(1));
            mvprintw(innerRow, boxX + 25, "%-15s", peer.location.c_str());
            mvprintw(innerRow, boxX + 45, "%dms", peer.ping);
            innerRow++;
        }
    }
    
    row += 12;
    mvprintw(row++, boxX + 3, "[R] Refresh    [A] Add Peer    [B] Back");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawKnowledge() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "KNOWLEDGE NETWORK");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 12, boxW, "Network Growth");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "KNOWLEDGE NETWORK GROWTH SCALE");
    mvprintw(innerRow++, boxX + 3, "============================================");
    innerRow++;
    
    const char* phases[] = {
        "Phase 1: Genesis",
        "Phase 2: Expansion",
        "Phase 3: Emergence",
        "Phase 4: Collective",
        "Phase 5: Global"
    };
    const char* ranges[] = {"[0 - 100K]", "[100K - 1M]", "[1M - 10M]", "[10M - 100M]", "[100M+]"};
    
    for (int i = 0; i < 5; i++) {
        mvprintw(innerRow, boxX + 3, "%-18s ", phases[i]);
        
        int barStart = boxX + 22;
        for (int j = 0; j < 20; j++) {
            if (i == 0 && j < 1) {
                attron(COLOR_PAIR(1));
                mvprintw(innerRow, barStart + j, "#");
                attroff(COLOR_PAIR(1));
            } else {
                mvprintw(innerRow, barStart + j, ".");
            }
        }
        
        if (i == 0) {
            attron(COLOR_PAIR(2));
            mvprintw(innerRow, boxX + 44, "0.0%%      %s   <--", ranges[i]);
            attroff(COLOR_PAIR(2));
        } else {
            mvprintw(innerRow, boxX + 44, "LOCKED    %s", ranges[i]);
        }
        innerRow++;
    }
    
    row += 14;
    drawBox(row, boxX, 8, boxW, "Your Contributions");
    
    innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Knowledge Shared:  %d entries", state.knowledgeShared);
    mvprintw(innerRow++, boxX + 3, "Validations:       %d", state.validations);
    mvprintw(innerRow++, boxX + 3, "Quality Score:     %.1f%%", static_cast<double>(state.qualityScore));
    mvprintw(innerRow++, boxX + 3, "Network Rank:      #%d", state.networkRank);
    
    row += 10;
    mvprintw(row++, boxX + 3, "[C] Contribute    [V] Validate    [S] Search    [B] Back");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawModel() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "LOCAL AI MODEL");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 70;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 9, boxW, "Model Status");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Model:    %s", state.model.name.empty() ? "not loaded" : state.model.name.c_str());
    
    if (state.model.status == "ACTIVE") {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow++, boxX + 3, "Status:   * %s", state.model.status.c_str());
        attroff(COLOR_PAIR(1));
    } else {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "Status:   * %s", state.model.status.c_str());
        attroff(COLOR_PAIR(2));
    }
    
    mvprintw(innerRow, boxX + 3, "Progress: ");
    int barX = boxX + 13;
    mvaddch(innerRow, barX, '[');
    for (int i = 0; i < 40; i++) {
        if (i < static_cast<int>(state.model.progress * 40)) {
            attron(COLOR_PAIR(1));
            mvprintw(innerRow, barX + 1 + i, "#");
            attroff(COLOR_PAIR(1));
        } else {
            mvaddch(innerRow, barX + 1 + i, ' ');
        }
    }
    mvaddch(innerRow, barX + 41, ']');
    mvprintw(innerRow++, barX + 43, "%d%%", static_cast<int>(state.model.progress * 100));
    
    mvprintw(innerRow++, boxX + 3, "Mode:     %s", state.model.mode.c_str());
    mvprintw(innerRow++, boxX + 3, "Uptime:   0h 0m");
    
    row += 11;
    drawBox(row, boxX, 8, boxW, "Earnings");
    
    innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Today:      +%.1f NGT", state.model.earningsToday);
    mvprintw(innerRow++, boxX + 3, "This Week:  +%.1f NGT", state.model.earningsWeek);
    mvprintw(innerRow++, boxX + 3, "Total:      +%.1f NGT", state.model.earningsTotal);
    
    row += 10;
    drawBox(row, boxX, 7, boxW, "Access Control");
    
    innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "[1] PRIVATE  - only you (default)");
    mvprintw(innerRow++, boxX + 3, "[2] SHARED   - invite nodes, set limit");
    mvprintw(innerRow++, boxX + 3, "[3] PUBLIC   - anyone can use");
    mvprintw(innerRow++, boxX + 3, "[4] PAID     - set price, earn NGT");
    
    row += 9;
    mvprintw(row++, boxX + 3, "[L] Load Model    [U] Unload    [C] Chat    [B] Back");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawAIChat() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "AI CHAT");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 3, boxW, "Model");
    if (state.model.name.empty()) {
        attron(COLOR_PAIR(2));
        mvprintw(row + 1, boxX + 3, "NO MODEL LOADED - Press [L] to load");
        attroff(COLOR_PAIR(2));
    } else {
        attron(COLOR_PAIR(1));
        mvprintw(row + 1, boxX + 3, "%s - READY", state.model.name.c_str());
        attroff(COLOR_PAIR(1));
    }
    
    row += 4;
    int chatBoxH = LINES - row - 8;
    drawBox(row, boxX, chatBoxH, boxW, "Conversation");
    
    int chatRow = row + 1;
    int maxChatLines = chatBoxH - 2;
    
    if (state.chatHistory.empty()) {
        if (state.model.name.empty()) {
            attron(COLOR_PAIR(2));
            mvprintw(chatRow++, boxX + 3, "Load a model first to start chatting.");
            mvprintw(chatRow++, boxX + 3, "Press [L] to load a model from ~/.synapsenet/models/");
            attroff(COLOR_PAIR(2));
        } else {
            attron(COLOR_PAIR(4));
            mvprintw(chatRow++, boxX + 3, "Model loaded. Type your message below.");
            attroff(COLOR_PAIR(4));
        }
    } else {
        int startIdx = 0;
        if (static_cast<int>(state.chatHistory.size()) > maxChatLines / 2) {
            startIdx = state.chatHistory.size() - maxChatLines / 2;
        }
        
        for (size_t i = startIdx; i < state.chatHistory.size() && chatRow < row + chatBoxH - 1; i++) {
            const auto& msg = state.chatHistory[i];
            if (msg.role == "user") {
                attron(COLOR_PAIR(1) | A_BOLD);
                mvprintw(chatRow++, boxX + 3, "You: ");
                attroff(COLOR_PAIR(1) | A_BOLD);
            } else {
                attron(COLOR_PAIR(4) | A_BOLD);
                mvprintw(chatRow++, boxX + 3, "AI: ");
                attroff(COLOR_PAIR(4) | A_BOLD);
            }
            
            std::string content = msg.content;
            int maxLineLen = boxW - 8;
            size_t pos = 0;
            while (pos < content.size() && chatRow < row + chatBoxH - 1) {
                std::string line = content.substr(pos, maxLineLen);
                mvprintw(chatRow++, boxX + 5, "%s", line.c_str());
                pos += maxLineLen;
            }
        }
    }
    
    if (state.aiGenerating) {
        attron(COLOR_PAIR(2) | A_BLINK);
        mvprintw(row + chatBoxH - 2, boxX + 3, "AI is thinking...");
        attroff(COLOR_PAIR(2) | A_BLINK);
    }
    
    row += chatBoxH + 1;
    drawBox(row, boxX, 3, boxW, "Input");
    
    std::string displayInput = inputBuffer;
    if (displayInput.length() > static_cast<size_t>(boxW - 10)) {
        displayInput = displayInput.substr(displayInput.length() - (boxW - 10));
    }
    mvprintw(row + 1, boxX + 3, "> %s_", displayInput.c_str());
    
    row += 4;
    mvprintw(row, boxX + 3, "[Enter] Send  [L] Load Model  [Esc/B] Back  [C] Clear");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawSecurity() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "SECURITY STATUS");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 12, boxW, "Quantum-Resistant Protection");
    
    int innerRow = row + 2;
    attron(COLOR_PAIR(1) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "QUANTUM-RESISTANT PROTECTION: ACTIVE");
    attroff(COLOR_PAIR(1) | A_BOLD);
    innerRow++;
    
    attron(COLOR_PAIR(1));
    mvprintw(innerRow++, boxX + 3, "Wallet Keys:      CRYSTALS-Dilithium (Post-Quantum)");
    mvprintw(innerRow++, boxX + 3, "Seed Phrase:      SPHINCS+ Protected");
    mvprintw(innerRow++, boxX + 3, "Network Comms:    CRYSTALS-Kyber Encrypted");
    mvprintw(innerRow++, boxX + 3, "Knowledge Data:   Lattice-based Encryption");
    attroff(COLOR_PAIR(1));
    innerRow++;
    
    mvprintw(innerRow++, boxX + 3, "Status: Your node is protected against quantum computer attacks");
    
    row += 14;
    drawBox(row, boxX, 10, boxW, "Security Layers");
    
    innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Layer 0: CLASSIC       Ed25519 + X25519 + AES-256-GCM");
    mvprintw(innerRow++, boxX + 3, "Layer 1: LATTICE PQC   ML-KEM-768 (Kyber) + ML-DSA-65");
    mvprintw(innerRow++, boxX + 3, "Layer 2: HASH PQC      SLH-DSA-128s (SPHINCS+)");
    mvprintw(innerRow++, boxX + 3, "Layer 3: ONE-TIME PAD  Vernam Cipher (XOR)");
    mvprintw(innerRow++, boxX + 3, "Layer 4: QKD           BB84/E91 (future hardware)");
    
    row += 12;
    mvprintw(row++, boxX + 3, "[B] Back to Dashboard");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawSettings() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "SETTINGS");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 60;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 14, boxW, "Configuration");
    
    int innerRow = row + 2;
    const char* settings[] = {
        "[1] Network Settings",
        "[2] Privacy Settings",
        "[3] Model Settings",
        "[4] Display Settings",
        "[5] Security Settings",
        "[6] Wallet Settings",
        "[7] Export Configuration",
        "[8] Import Configuration",
        "[9] Reset to Defaults"
    };
    
    for (int i = 0; i < 9; i++) {
        if (i == menuSelection) {
            attron(A_REVERSE);
        }
        mvprintw(innerRow++, boxX + 5, "%s", settings[i]);
        if (i == menuSelection) {
            attroff(A_REVERSE);
        }
    }
    
    row += 16;
    mvprintw(row++, boxX + 3, "[Up/Down] Navigate    [Enter] Select    [B] Back");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawMining() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "MINING ACTIVITY");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 76;
    int boxX = (COLS - boxW) / 2;
    
    centerText(row++, "--------------------------------------------------------------------------------");
    
    row++;
    mvprintw(row, boxX + 3, "Progress: ");
    int barX = boxX + 13;
    for (int i = 0; i < 45; i++) {
        if (i < static_cast<int>(state.miningProgress * 45)) {
            attron(COLOR_PAIR(1));
            mvprintw(row, barX + i, "#");
            attroff(COLOR_PAIR(1));
        } else {
            mvprintw(row, barX + i, " ");
        }
    }
    mvprintw(row++, barX + 46, "%d%% Processing Knowledge", static_cast<int>(state.miningProgress * 100));
    
    row += 2;
    drawBox(row, boxX, 10, boxW, "Recent Contributions");
    
    int innerRow = row + 2;
    if (state.recentContributions.empty()) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "No contributions yet.");
        mvprintw(innerRow++, boxX + 3, "Start contributing knowledge to earn NGT!");
        attroff(COLOR_PAIR(2));
    } else {
        for (const auto& contrib : state.recentContributions) {
            attron(COLOR_PAIR(1));
            mvprintw(innerRow, boxX + 3, "[%s]", contrib.time.c_str());
            attroff(COLOR_PAIR(1));
            mvprintw(innerRow, boxX + 15, "%s: %s", contrib.type.c_str(), contrib.name.c_str());
            attron(COLOR_PAIR(1));
            mvprintw(innerRow, boxX + 55, "+%.1f NGT", contrib.reward);
            attroff(COLOR_PAIR(1));
            innerRow++;
        }
    }
    
    row += 12;
    mvprintw(row++, boxX + 3, "[C] Contribute    [V] Validate    [B] Back");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawModelLoader() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "LOAD AI MODEL");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 70;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 6, boxW, "Model Directory");
    
    int innerRow = row + 2;
    std::string modelDir = std::getenv("HOME") ? 
                           std::string(std::getenv("HOME")) + "/.synapsenet/models" : 
                           "./models";
    mvprintw(innerRow++, boxX + 3, "Path: %s", modelDir.c_str());
    mvprintw(innerRow++, boxX + 3, "Supported: .gguf files (llama.cpp format)");
    
    row += 7;
    drawBox(row, boxX, 12, boxW, "Available Models");
    
    innerRow = row + 2;
    
    std::vector<std::string> models;
    std::string homeDir = std::getenv("HOME") ? std::getenv("HOME") : ".";
    std::string fullPath = homeDir + "/.synapsenet/models";
    
    if (std::filesystem::exists(fullPath)) {
        for (const auto& entry : std::filesystem::directory_iterator(fullPath)) {
            if (entry.path().extension() == ".gguf") {
                models.push_back(entry.path().filename().string());
            }
        }
    }
    
    if (models.empty()) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "No models found.");
        mvprintw(innerRow++, boxX + 3, "");
        mvprintw(innerRow++, boxX + 3, "To add models:");
        mvprintw(innerRow++, boxX + 3, "1. Create directory: mkdir -p ~/.synapsenet/models");
        mvprintw(innerRow++, boxX + 3, "2. Download a GGUF model (e.g. from huggingface.co)");
        mvprintw(innerRow++, boxX + 3, "3. Place .gguf file in ~/.synapsenet/models/");
        attroff(COLOR_PAIR(2));
    } else {
        for (size_t i = 0; i < models.size() && i < 8; i++) {
            if (static_cast<int>(i) == menuSelection) {
                attron(A_REVERSE | COLOR_PAIR(1));
            }
            mvprintw(innerRow++, boxX + 3, "[%zu] %s", i + 1, models[i].c_str());
            if (static_cast<int>(i) == menuSelection) {
                attroff(A_REVERSE | COLOR_PAIR(1));
            }
        }
    }
    
    row += 14;
    if (!models.empty()) {
        mvprintw(row++, boxX + 3, "[1-9] Select Model    [Enter] Load Selected    [B] Back");
    } else {
        mvprintw(row++, boxX + 3, "[B] Back");
    }
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawSendNGT() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "SEND NGT");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 70;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 8, boxW, "Your Balance");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Address:   %s", state.wallet.address.c_str());
    attron(COLOR_PAIR(1) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "Available: %.2f NGT", state.wallet.balance);
    attroff(COLOR_PAIR(1) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "Pending:   %.2f NGT", state.wallet.pending);
    
    row += 10;
    drawBox(row, boxX, 10, boxW, "Send Transaction");
    
    innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "To Address:");
    mvprintw(innerRow++, boxX + 3, "> %s_", state.sendToAddress.c_str());
    innerRow++;
    mvprintw(innerRow++, boxX + 3, "Amount (NGT):");
    if (state.sendAmount > 0) {
        mvprintw(innerRow++, boxX + 3, "> %.2f", state.sendAmount);
    } else {
        mvprintw(innerRow++, boxX + 3, "> _");
    }
    innerRow++;
    
    if (state.listeningPort == 0) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "Network offline - cannot send");
        attroff(COLOR_PAIR(2));
    } else if (state.peers.empty()) {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "No peers connected - transaction will be local");
        attroff(COLOR_PAIR(2));
    }
    
    row += 12;
    mvprintw(row++, boxX + 3, "[Enter] Send    [Esc/B] Cancel");
    
    drawStatusBar();
    ::refresh();
}

void TUI::Impl::drawReceiveNGT() {
    clear();
    int row = 1;
    
    attron(COLOR_PAIR(4) | A_BOLD);
    centerText(row++, "RECEIVE NGT");
    attroff(COLOR_PAIR(4) | A_BOLD);
    
    row++;
    int boxW = 70;
    int boxX = (COLS - boxW) / 2;
    
    drawBox(row, boxX, 12, boxW, "Your Wallet Address");
    
    int innerRow = row + 2;
    mvprintw(innerRow++, boxX + 3, "Share this address to receive NGT:");
    innerRow++;
    
    attron(COLOR_PAIR(1) | A_BOLD);
    mvprintw(innerRow++, boxX + 3, "%s", state.wallet.address.c_str());
    attroff(COLOR_PAIR(1) | A_BOLD);
    
    innerRow += 2;
    mvprintw(innerRow++, boxX + 3, "Network Status:");
    if (state.listeningPort > 0) {
        attron(COLOR_PAIR(1));
        mvprintw(innerRow++, boxX + 3, "  ONLINE - Port %d", state.listeningPort);
        mvprintw(innerRow++, boxX + 3, "  Ready to receive transactions");
        attroff(COLOR_PAIR(1));
    } else {
        attron(COLOR_PAIR(2));
        mvprintw(innerRow++, boxX + 3, "  OFFLINE - Cannot receive from network");
        attroff(COLOR_PAIR(2));
    }
    
    row += 14;
    mvprintw(row++, boxX + 3, "[B] Back to Wallet");
    
    drawStatusBar();
    ::refresh();
}


TUI::TUI() : impl_(std::make_unique<Impl>()) {
    impl_->initDefaultState();
}

TUI::~TUI() {
    shutdown();
}

bool TUI::init() {
    initscr();
    if (!has_colors()) {
        endwin();
        return false;
    }
    
    start_color();
    use_default_colors();
    
    init_pair(1, COLOR_GREEN, -1);
    init_pair(2, COLOR_YELLOW, -1);
    init_pair(3, COLOR_RED, -1);
    init_pair(4, COLOR_CYAN, -1);
    init_pair(5, COLOR_MAGENTA, -1);
    init_pair(6, COLOR_BLUE, -1);
    init_pair(7, COLOR_WHITE, -1);
    
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0);
    nodelay(stdscr, TRUE);
    
    impl_->running = true;
    impl_->screen = Screen::BOOT;
    
    return true;
}

void TUI::run() {
    std::vector<std::string> availableModels;
    
    while (impl_->running) {
        switch (impl_->screen) {
            case Screen::BOOT:
                impl_->drawBoot();
                break;
            case Screen::INIT:
                impl_->drawInit();
                break;
            case Screen::NETWORK_DISCOVERY:
                impl_->drawNetworkDiscovery();
                break;
            case Screen::SYNCING:
                impl_->drawSyncing();
                break;
            case Screen::WELCOME:
                impl_->drawWelcome();
                break;
            case Screen::WALLET_CREATE:
                impl_->drawWalletCreate();
                break;
            case Screen::WALLET_CREATED:
                impl_->drawWalletCreated();
                break;
            case Screen::CONNECTED:
                impl_->drawConnected();
                break;
            case Screen::DASHBOARD:
                impl_->drawDashboard();
                break;
            case Screen::WALLET:
                impl_->drawWallet();
                break;
            case Screen::WALLET_SEND:
                impl_->drawSendNGT();
                break;
            case Screen::WALLET_RECEIVE:
                impl_->drawReceiveNGT();
                break;
            case Screen::NETWORK:
                impl_->drawNetwork();
                break;
            case Screen::KNOWLEDGE:
                impl_->drawKnowledge();
                break;
            case Screen::MODEL:
                impl_->drawModelLoader();
                break;
            case Screen::AI_CHAT:
                impl_->drawAIChat();
                break;
            case Screen::MINING:
                impl_->drawMining();
                break;
            case Screen::SETTINGS:
                impl_->drawSettings();
                break;
            default:
                impl_->drawDashboard();
                break;
        }
        
        int ch = getch();
        if (ch != ERR) {
            if (impl_->inputHandler) {
                impl_->inputHandler(ch);
            }
            
            if (impl_->screen == Screen::AI_CHAT) {
                if (ch == '\n' || ch == KEY_ENTER) {
                    if (!impl_->inputBuffer.empty() && !impl_->state.model.name.empty()) {
                        ChatMessage userMsg;
                        userMsg.role = "user";
                        userMsg.content = impl_->inputBuffer;
                        impl_->state.chatHistory.push_back(userMsg);
                        
                        impl_->state.aiGenerating = true;
                        impl_->drawAIChat();
                        
                        std::string response = "I received your message: \"" + impl_->inputBuffer + "\". ";
                        response += "This is a local AI response. In production, this would use the loaded model for inference.";
                        
                        ChatMessage aiMsg;
                        aiMsg.role = "assistant";
                        aiMsg.content = response;
                        impl_->state.chatHistory.push_back(aiMsg);
                        
                        impl_->state.aiGenerating = false;
                        impl_->inputBuffer.clear();
                    }
                } else if (ch == KEY_BACKSPACE || ch == 127 || ch == 8) {
                    if (!impl_->inputBuffer.empty()) {
                        impl_->inputBuffer.pop_back();
                    }
                } else if (ch == 27) {
                    impl_->screen = Screen::DASHBOARD;
                    impl_->inputBuffer.clear();
                } else if (ch == 'l' || ch == 'L') {
                    impl_->screen = Screen::MODEL;
                    impl_->menuSelection = 0;
                } else if (ch == 'c' || ch == 'C') {
                    impl_->state.chatHistory.clear();
                } else if (ch >= 32 && ch < 127) {
                    impl_->inputBuffer += static_cast<char>(ch);
                }
            } else if (impl_->screen == Screen::MODEL) {
                std::string homeDir = std::getenv("HOME") ? std::getenv("HOME") : ".";
                std::string modelDir = homeDir + "/.synapsenet/models";
                
                availableModels.clear();
                if (std::filesystem::exists(modelDir)) {
                    for (const auto& entry : std::filesystem::directory_iterator(modelDir)) {
                        if (entry.path().extension() == ".gguf") {
                            availableModels.push_back(entry.path().string());
                        }
                    }
                }
                
                if (ch >= '1' && ch <= '9') {
                    int idx = ch - '1';
                    if (idx < static_cast<int>(availableModels.size())) {
                        impl_->menuSelection = idx;
                    }
                } else if (ch == '\n' || ch == KEY_ENTER) {
                    if (impl_->menuSelection < static_cast<int>(availableModels.size())) {
                        impl_->state.modelPath = availableModels[impl_->menuSelection];
                        impl_->state.model.name = std::filesystem::path(impl_->state.modelPath).filename().string();
                        impl_->state.model.status = "ACTIVE";
                        impl_->state.model.progress = 1.0;
                        impl_->screen = Screen::AI_CHAT;
                    }
                } else if (ch == 'b' || ch == 'B' || ch == 27) {
                    impl_->screen = Screen::DASHBOARD;
                } else if (ch == KEY_UP) {
                    if (impl_->menuSelection > 0) impl_->menuSelection--;
                } else if (ch == KEY_DOWN) {
                    if (impl_->menuSelection < static_cast<int>(availableModels.size()) - 1) {
                        impl_->menuSelection++;
                    }
                }
            } else if (impl_->screen == Screen::WALLET) {
                if (ch == '1') {
                    impl_->state.sendToAddress.clear();
                    impl_->state.sendAmount = 0.0;
                    impl_->screen = Screen::WALLET_SEND;
                } else if (ch == '2') {
                    impl_->screen = Screen::WALLET_RECEIVE;
                } else if (ch == 'b' || ch == 'B' || ch == 27) {
                    impl_->screen = Screen::DASHBOARD;
                }
            } else if (impl_->screen == Screen::WALLET_SEND) {
                if (ch == '\n' || ch == KEY_ENTER) {
                    if (!impl_->state.sendToAddress.empty() && impl_->state.sendAmount > 0) {
                        if (impl_->state.sendAmount <= impl_->state.wallet.balance) {
                            impl_->state.wallet.balance -= impl_->state.sendAmount;
                            impl_->state.wallet.pending += impl_->state.sendAmount;
                            impl_->state.sendToAddress.clear();
                            impl_->state.sendAmount = 0.0;
                            impl_->screen = Screen::WALLET;
                        }
                    }
                } else if (ch == KEY_BACKSPACE || ch == 127 || ch == 8) {
                    if (!impl_->state.sendToAddress.empty()) {
                        impl_->state.sendToAddress.pop_back();
                    }
                } else if (ch == 27 || ch == 'b' || ch == 'B') {
                    impl_->screen = Screen::WALLET;
                } else if (ch >= 32 && ch < 127) {
                    if (impl_->state.sendToAddress.length() < 64) {
                        impl_->state.sendToAddress += static_cast<char>(ch);
                    }
                }
            } else if (impl_->screen == Screen::WALLET_RECEIVE) {
                if (ch == 'b' || ch == 'B' || ch == 27) {
                    impl_->screen = Screen::WALLET;
                }
            } else {
                switch (ch) {
                    case 'q':
                    case 'Q':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->running = false;
                        } else {
                            impl_->screen = Screen::DASHBOARD;
                        }
                        break;
                    case ' ':
                        if (impl_->screen == Screen::BOOT) {
                            impl_->screen = Screen::INIT;
                            impl_->initStep = 0;
                        }
                        break;
                    case '\n':
                    case KEY_ENTER:
                        if (impl_->screen == Screen::WALLET_CREATED || impl_->screen == Screen::CONNECTED) {
                            impl_->screen = Screen::DASHBOARD;
                        }
                        break;
                    case '1':
                        if (impl_->screen == Screen::WELCOME) {
                            impl_->state.generatedSeedWords.clear();
                            impl_->screen = Screen::WALLET_CREATE;
                        } else if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::AI_CHAT;
                        }
                        break;
                    case '2':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::MODEL;
                            impl_->menuSelection = 0;
                        }
                        break;
                    case '3':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::WALLET;
                        }
                        break;
                    case '4':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::MINING;
                        }
                        break;
                    case '5':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::NETWORK;
                        }
                        break;
                    case '6':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::KNOWLEDGE;
                        }
                        break;
                    case '7':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::SETTINGS;
                        }
                        break;
                    case 'y':
                    case 'Y':
                        if (impl_->screen == Screen::WALLET_CREATE) {
                            std::string seedConcat;
                            for (const auto& word : impl_->state.generatedSeedWords) {
                                seedConcat += word;
                            }
                            
                            std::random_device rd;
                            auto now = std::chrono::high_resolution_clock::now();
                            auto nanos = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
                            uint32_t timestamp = static_cast<uint32_t>(nanos);
                            uint32_t random_part = rd();
                            uint32_t thread_part = std::hash<std::thread::id>{}(std::this_thread::get_id());
                            
                            std::seed_seq seq(seedConcat.begin(), seedConcat.end());
                            std::mt19937_64 gen(seq);
                            gen.discard(static_cast<size_t>((timestamp ^ random_part ^ thread_part) % 10000));
                            
                            std::string addr = "ngt1";
                            const char* hexChars = "0123456789abcdef";
                            std::uniform_int_distribution<> dis(0, 15);
                            for (int i = 0; i < 52; i++) {
                                addr += hexChars[dis(gen)];
                            }
                            
                            std::uniform_int_distribution<int> portDis(10000, 65500);
                            uint16_t selectedPort = portDis(gen);
                            
                            impl_->state.wallet.address = addr;
                            impl_->state.nodeId = "node_" + addr.substr(4, 8);
                            impl_->state.listeningPort = selectedPort;
                            impl_->state.isFirstRun = false;
                            impl_->screen = Screen::WALLET_CREATED;
                        }
                        break;
                    case 'b':
                    case 'B':
                        impl_->screen = Screen::DASHBOARD;
                        break;
                    case 'c':
                    case 'C':
                        break;
                    case 's':
                    case 'S':
                        if (impl_->screen == Screen::DASHBOARD) {
                            impl_->screen = Screen::SETTINGS;
                        }
                        break;
                    case 'l':
                    case 'L':
                        if (impl_->screen == Screen::DASHBOARD || impl_->screen == Screen::AI_CHAT) {
                            impl_->screen = Screen::MODEL;
                            impl_->menuSelection = 0;
                        }
                        break;
                    case KEY_UP:
                        if (impl_->menuSelection > 0) {
                            impl_->menuSelection--;
                        }
                        break;
                    case KEY_DOWN:
                        if (impl_->menuSelection < 8) {
                            impl_->menuSelection++;
                        }
                        break;
                    case 27:
                        impl_->screen = Screen::DASHBOARD;
                        break;
                }
            }
        }
        
        impl_->frameCounter++;
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

void TUI::shutdown() {
    if (impl_->running) {
        impl_->running = false;
        endwin();
    }
}

bool TUI::isRunning() const {
    return impl_->running;
}

void TUI::switchScreen(Screen screen) {
    impl_->screen = screen;
}

Screen TUI::currentScreen() const {
    return impl_->screen;
}

void TUI::refresh() {
    ::refresh();
}

void TUI::updateStatus(const StatusInfo& status) {
    impl_->status = status;
}

void TUI::showMessage(const std::string& msg, Color color) {
    int row = LINES - 3;
    attron(COLOR_PAIR(static_cast<int>(color)));
    mvprintw(row, 2, "%s", msg.c_str());
    attroff(COLOR_PAIR(static_cast<int>(color)));
    ::refresh();
}

void TUI::showError(const std::string& err) {
    showMessage(err, Color::RED);
}

void TUI::showProgress(const std::string& label, double progress) {
    int row = LINES - 4;
    mvprintw(row, 2, "%s: ", label.c_str());
    impl_->drawProgressBar(row, 2 + label.length() + 2, 40, progress, 1);
    ::refresh();
}

void TUI::drawBox(int y, int x, int h, int w, const std::string& title) {
    impl_->drawBox(y, x, h, w, title.c_str());
}

void TUI::drawText(int y, int x, const std::string& text, Color color) {
    attron(COLOR_PAIR(static_cast<int>(color)));
    mvprintw(y, x, "%s", text.c_str());
    attroff(COLOR_PAIR(static_cast<int>(color)));
}

void TUI::drawProgressBar(int y, int x, int w, double progress, Color color) {
    impl_->drawProgressBar(y, x, w, progress, static_cast<int>(color));
}

void TUI::onInput(std::function<void(int)> handler) {
    impl_->inputHandler = handler;
}

void TUI::onCommand(std::function<void(const std::string&)> handler) {
    impl_->commandHandler = handler;
}

void TUI::setNetworkPort(uint16_t port) {
    impl_->state.listeningPort = port;
}

void TUI::setNetworkOnline(bool online) {
    impl_->state.networkOnline = online;
}

void TUI::setPeerCount(size_t count) {
    impl_->state.peers.resize(count);
    for (size_t i = 0; i < count; i++) {
        if (i >= impl_->state.peers.size() || impl_->state.peers[i].id.empty()) {
            NodeInfo peer;
            peer.id = "peer_" + std::to_string(i + 1);
            peer.nodeId = peer.id;
            peer.address = "192.168.1." + std::to_string(100 + i);
            peer.location = "Unknown";
            peer.port = 8333;
            peer.latency = 50 + (i * 10);
            peer.ping = static_cast<int>(peer.latency);
            peer.version = "0.1.0";
            peer.isInbound = (i % 2 == 0);
            if (i < impl_->state.peers.size()) {
                impl_->state.peers[i] = peer;
            } else {
                impl_->state.peers.push_back(peer);
            }
        }
    }
}

void TUI::updateNetworkInfo(const NetworkInfo& info) {
    impl_->state.network = info;
}

void TUI::updatePeers(const std::vector<NodeInfo>& peers) {
    impl_->state.peers = peers;
}

void TUI::updateModelInfo(const AIModelInfo& info) {
    impl_->state.model = info;
}

void TUI::updateWalletInfo(const WalletInfo& info) {
    impl_->state.wallet = info;
}

std::string TUI::prompt(const std::string& message) {
    return "";
}

bool TUI::confirm(const std::string& message) {
    return false;
}

int TUI::menu(const std::string& title, const std::vector<std::string>& options) {
    return 0;
}

}
}
